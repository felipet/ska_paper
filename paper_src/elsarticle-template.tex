\documentclass[review]{elsarticle}

\usepackage[utf8]{inputenc}

\usepackage{lineno,hyperref}
\modulolinenumbers[5]

%% Change to final when definitive version of the paper will be generated.
\usepackage[final, lang=spanish, mode=multiuser]{fixme}

\FXRegisterAuthor{kcmd}{kenv}{klyone}
\FXRegisterAuthor{fcmd}{fenv}{felipetg}

\journal{Journal of \LaTeX\ Templates}

%%%%%%%%%%%%%%%%%%%%%%%
%% Elsevier bibliography styles
%%%%%%%%%%%%%%%%%%%%%%%
%% To change the style, put a % in front of the second line of the current style and
%% remove the % from the second line of the style you would like to use.
%%%%%%%%%%%%%%%%%%%%%%%

%% Numbered
%\bibliographystyle{model1-num-names}

%% Numbered without titles
%\bibliographystyle{model1a-num-names}

%% Harvard
%\bibliographystyle{model2-names.bst}\biboptions{authoryear}

%% Vancouver numbered
%\usepackage{numcompress}\bibliographystyle{model3-num-names}

%% Vancouver name/year
%\usepackage{numcompress}\bibliographystyle{model4-names}\biboptions{authoryear}

%% APA style
%\bibliographystyle{model5-names}\biboptions{authoryear}

%% AMA style
%\usepackage{numcompress}\bibliographystyle{model6-num-names}

%% `Elsevier LaTeX' style
\bibliographystyle{elsarticle-num}
%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frontmatter}

\title{A PPS distribution system for SKA}
%\title{Elsevier \LaTeX\ template\tnoteref{mytitlenote}}
%\tnotetext[mytitlenote]{Fully documented templates are available in the elsarticle package on %\href{http://www.ctan.org/tex-archive/macros/latex/contrib/elsarticle}{CTAN}.}

%% Group authors per affiliation:
%\author{Elsevier\fnref{myfootnote}}
%\address{Radarweg 29, Amsterdam}
%\fntext[myfootnote]{Since 1880.}

%% Group authors per affiliation:
\author{Miguel Jiménez-López, Felipe Torres-González, Javier Díaz}
\address{CITIC, ETSIIT, University of Granada}

%% or include affiliations in footnotes:
%\author[mymainaddress,mysecondaryaddress]{Elsevier Inc}
%\ead[url]{www.elsevier.com}

%\author[mysecondaryaddress]{Global Customer Service\corref{mycorrespondingauthor}}
%\cortext[mycorrespondingauthor]{Corresponding author}
%\ead{support@elsevier.com}

%\address[mymainaddress]{1600 John F Kennedy Boulevard, Philadelphia}
%\address[mysecondaryaddress]{360 Park Avenue South, New York}

%\listoffixmes

\begin{abstract} 
	The present paper describes the PPS distribution system for the Square Kilometer Array. The system architecture is described in depth. 
\end{abstract}

\begin{keyword}
	Square Kilometer Array, White Rabbit, Synchronization, Network
\end{keyword}

\end{frontmatter}

\linenumbers

\section{Introduction}

\section{The SKA project}

\section{The White Rabbit synchronization protocol}

The White Rabbit (WR) protocol is an open hardware/software technology that improves the Gigabit Ethernet (GbE) and PTPv2 protocol for optical fiber links. Its main goal is to provide a timing synchronization with an accuracy better than a nanosecond and the precision in the scale of picoseconds. WR implements mechanisms to ensure the deterministic and reliable data transfer between thousand of nodes connected with large links up to 10 km As conventional networks, WR proposes a hierarchical topology with a root node that is responsible for distributing the reference clock to other devices. This element is known as Grand Master and it is driven by a GPS or atomic clock. The intermediate levels of the network are composed of WR Switches that are multi-port devices and behave as Precise Time Protocol version 2 (PTPv2) Boundary Clock (BC). The different ports of the WR Switch are divided on two types: one of them is the slave (uplink) and connects the Switch with the upper layer and the other ports are masters (downlinks) and they are charged to propagate the synchronization to the next level of the hierarchy. The nodes of the last level of the network are known as Slave devices and its main purpose is recovering the clock signal of the link and synchronizes its local oscillator.

WR is based on other technologies such as Synchronous Ethernet (SyncE), an extension of PTPv2 (WR-PTP) and additional phase alignment techniques. The SyncE allows the physical layer of the Ethernet protocol to transmit the master clock inside the data stream. Then, the slave nodes can recover it and configures its local oscillators to follow it. The WR-PTP implements extra messages in the PTPv2 protocol and it is proposed to be included in the new PTP release (PTPv3) as a High Accuracy profile. WR also uses additional phase alignment techniques as the Digital Dual Mixed Time Difference (DDMTD) that is a module responsible for measuring the phase between two clocks. This information is used to change the frequency of the local oscillator for the synchronization process.

WR is designed to be use in a Field Programmable Gate Array (FPGA) device and the source code is mainly written in HDL languages such as VHDL or Verilog. Moreover, there are several platforms that can implement WR which ensures the vendor-independent feature of WR. The main Intellectual Property (IP) block is the WR PTP core (WRPC) for WR nodes and the Real Time Subsystem (RTS) for WR switches. The most common WR nodes are based on carrier boards such as SPEC or SVEC and can be plugged in a PCIe/VME socket of a conventional PC. Some WR nodes have a standalone mode but in this case they can not benefit of high level features usually provided by a PC CPU.

\kcmdnote{Here, I am not sure if we have to describe a little the WR-ZEN because in next section will be discussed in detail. However, we have to present it and I think that maybe some information can be repeated.}

The WR Zynq Embedded Node (WR-ZEN) is a new generation board that brings a Xilinx Zynq System-on-Chip (SoC). The Zynq SoC is composed of a FPGA and a hard ARM dual core microprocessor that can run a \textsc{bare-metal} application or a standard Operating System such as Linux. The WR-ZEN has been proposed to be used in the SKA project to implement the PPS distribution system that will be discussed in detail in the next section.

\section{The PPS distribution system for SKA}

%% ---------------- From WR-ZEN article (EFTF2016) ------------------------
%
%The WR-ZEN is a new kind of WR node that incorporates
%a FPGA device and a hard ARM dual core microprocessor
%inside the same chip. The ARM is able to run a Linux kernel
%and this eliminates the need to use a conventional PC with an
%operating system. The flexibility of the platform has motivated
%that WR-ZEN is under study to be used in important scientific
%infrastructures such as Square Kilometer Array [11] (SKA)
%and Cherenkov Telescope Array [12] (CTA) among others.
%
%% ------------------------------------------------------------------------

The PPS distribution system for SKA is based on the WR-ZEN platform and implements the WR technology in order to ensure the synchronization accuracy in the system. The first design of the PPS system includes the Fine Delay FMC card that is used to generate the timing signals to be transmitted over the link.

\subsection{Hardware}

%% ---------------- From WR-ZEN article (EFTF2016) ------------------------
%
%The WR-ZEN is a small stand-alone board that integrates
%the latest Xilinx Zynq Z-7015 device with a Dual ARM
%Cortex-A9 MPCore with CoreSight and containing an Artix
%FPGA-logic with 74K logic cells, 380KB of embedded mem-
%ory and 160 DSP blocks. It has two optical SFP Ethernet
%interfaces, two copper Ethernet ports and the FMC expansion
%connector. On addition to FMC, a SAMTEC connector is
%available for developing of simple expansion boards and some
%USB sockets for monitoring. The WR-ZEN node is provided
%with improved oscillators, PLLs and a clocking scheme that
%provides significant better short term stability than previous
%WR node designs. It also includes several SMA outputs that
%can be configured to generate signals from the FPGA and an
%input that allows the WR-ZEN to behave as grandmaster. The
%WR-ZEN can be used with several FMC cards depending on
%the application: ADC, DAC, TDC, DDS, Fine delay, Digital
%I/O, etc.
%
%% ------------------------------------------------------------------------

The WR-ZEN is a board designed by Seven Solutions company and contains a Xilinx Zynq SoC. This SoC has a ARM dual core microprocessor (Cortex-A9 MPCore with CoreSight) and a FPGA device (Artix with 74K logic cells, 380KB of embedded memory and 160 DSP blocks). This versatile architecture removes the necessity of a conventional PC because all the high-level software components can be implemented in the on-board processor. The WR-ZEN has been designed with an improved clocking scheme in relation to older WR nodes. It has better oscillators and additional PLL to be capable to generate a wide range of frequencies for several kind of different applications. The WR-ZEN is fully connected thanks to its two optical fiber SFP interfaces and two RJ45 sockets and has other standard ports such as FMC, SAMTEC, UART, I2C, SPI, etc. The expansion connectors (FMC and SAMTEC) are though to add other boards that implement specific features or capabilities. Typical applications for the FMC mezzanine board are Analog to Digital Converter (ADC), Digital to Analog Converter (DAC), Time to Digital Converter (TDC), Fine Delay, Digital I/O (DIO), etc. The SAMTEC connector is used to add extra circuitry to provide redundancy (duplicate power supply) and other additional components such as fans. 

\subsection{Gateware}

%% ---------------- From WR-ZEN article (EFTF2016) ------------------------
%
%The gateware refers to the design that must be programmed
%in the Programmable Logic (PL) and the Processing system
%(PS) configuration to be applied. The PL is based on the Wish-
%bone (WB) bus [13] and has a main crossbar that interconnects
%the different IP cores.
%In the Fig. 2, the PL architecture is represented in more
%detail.
%* GIGABIT TRANSCEIVER PORTS (GTP): These
%blocks contain primitives to transfer data through a
%high performance dedicated interfaces. The GTPs are
%connected to the SFP sockets and allow to send/receive
%packets to/from the Gigabit Ethernet network.
%* WR PTP DUAL PORT CORE (WRPC-2P): It is the
%key core for WR nodes and contains all the elements
%needed to implement the WR protocol for two optical
%fiber ports.
%* AXI TO WB BRIDGE (AXI-WB BRIDGE): The PS
%must be able to talk to the PL. However, the PS
%uses the AMBA/AXI bus specification instead of the
%WB one of the PL. The AXI-WB bridge is able to
%convert from WB transactions to AXI transactions and
%viceversa.
%* FMC CORE: This IP core gives the specific function-
%alities for a certain kind of FMC card. In the reference
%design, the Fine Delay FMC core is included.
%* NETWORK INTERFACE CORE (NIC): It provides a
%network controller that is directly accesible from the
%Linux kernel. The NIC module can be managed like a
%standard network interface thanks to a specific driver.
%The gateware design carries out a WR compliant node
%with network capabilities and support for several FMC cards.
%However, the reference design only uses the Fine Delay FMC
%card, it can be extended easily to work with other cards such
%as DIO, TDC, ADC, etc.
%
%% ------------------------------------------------------------------------

The Gateware is referred to all components that will be programmed in the FPGA device. The reference design is built on two different levels. The former uses the AMBA bus specification and considers the main elements for the Zynq ecosystem and includes several components such as Zynq Processing subsystem that takes care of configuring the ARM microprocessor and controlling the bus interconnections with it, a reset and clocking module that manages the clock and reset signals, an AXI QSPI core to program the hardware PLL chip, an AXI crossbar to glue everything and a specific IP core that represents the next level of the design and is explained in following lines.

The second level is referred to the specific IP core that takes into consideration the WR protocol and other basic features such as Gigabit networking, serial debug communication, Timestamp mechanism, etc. This module uses the Wishbone Open Cores bus specification and is mainly vendor-independent. It is composed of many IP cores that are interconnected through a WB crossbar that allows bidirectional communication between any two IP cores. Moreover, the crossbar can store Self Descriptor Bus (SDB) information about the different components attached to it in order to discover them with a scan operation. Thanks to it, the WB peripherals can be discovered automatically by software tools and this allows not to hard-code the different addresses inside the source code improving the maintainability of the system. The main modules at this level are the following:

\begin{itemize}
	\item{\textbf{AXI-WB bridge:} This bridge converts transactions between WB and AXI buses. This is important because the Zynq Processing System is designed to use the AXI bus and the original project of WR was developed with the Open Core WB bus. }
	\item{\textbf{WR Dual Port core:} It is most important module for WR nodes and it is charged to implement the WR protocol. The internal architecture of this module includes a soft-microprocessor (LM32) that runs a specific bare-metal program for the WR protocol. The WR endpoints includes some state machines to manage Ethernet packets of a Gigabit network. The Mini-NIC core receives and sends WR-PTP packets for the WR protocol. The LM32 is programed with a specific firmware for WR that is contained in the WB RAM. The WB Syscon is the general controller of the system and includes an UART, I2C, and control registers. The WB PPSgen contains the timebase counter for the WR technology and the SoftPLL is a special component that perform phase measurement between different clocks and has a PI loop to set up the DAC chip on the board to change the local oscillator frequency. }
	\item{\textbf{WB Crossbar:} It is responsible to join all the modules in order to allow communication between them. However, the real design is more complex because it has several WB crossbar at different hierarchy levels. }
	\item{\textbf{GT module:} Gitabit Transceiver are device specific primitives to implement the high speed interfaces. They are used to create two Gigabit Ethernet port for optical links through a SFP module.}
	\item{\textbf{NICs component:} They are responsible to receive/transmit Ethernet packets from/to the network. However, its initial design is not suitable for high bandwidth interfaces because it does incorporate a DMA controller. 
	%This feature is planned future improvement for the project.
	}
	\item{\textbf{TxTSU core:} When a packet is received from the network, the timestamp is appended to it as Out-of-Band (OOB) data. So, the software driver in the ARM can recover this information reading from the packet. However, for the transmitted packets, it is not possible. To solve this problem, a Transmit Timestamp Unit is added to the design. Its main purpose is to store timestamps for outgoing packets in a FIFO memory until the ARM accesses them. Thanks to this trick, we can get the timestamp for every packet. 
		
	%At this point, there are other enhancement to be into consideration. The timestamp granularity is limited by the clock %frequency of the system. An interesting task is to extend the precision to nanosecond scale as White Rabbit technology %promises.
	}
	\item{\textbf{Fine Delay FMC module:} The main purpose of this core is to implement a controller for the Fine Delay FMC mezzanine card. This board configures a delay to transmit a signal from the TTL trigger buffer to one of its four outputs. The delay range is between 600 ns and 120 s with a resolution of 1 ns. In addition, more complex mode can be programed and a wide variety of signal can be generated.}
	\item{\textbf{WB I2C arbiter:} This simple module is responsible to multiplex several I2C bus transactions that have to use the same I2C physical bus.}
\end{itemize}

\subsection{Firmware}

The LM32 soft-microprocessor is responsible for implementing the WR protocol. The code is written in C language and considers low level hardware drivers for each IP core and the PTP Port to Silicon (PPSI) that includes the PTPv2 stack with some add-ons for WR. In addition, a simple Command Language Interface (CLI) is introduced to allow the user interaction (think that some WR nodes can work in standalone mode and does not have an on-board hard microprocessor). The main tasks for the WR firmware is to implement the WR-PTP protocol and the DACs control by a PI loop. 

\kcmdnote{What more information can we add at this point?}
%% More information about WR-PTP??
The WR-PTP is implemented in two flavours: no POSIX and PPSi. The fist is a simple version as its name indicates, is not POSIX compliant. This is the old implementation and it has been replace with the PPSi that is POSIX compliant.

The PI loop for DACs is coded using an IRQ handler for the SoftPLL module. It is responsible to measure phase differences between clocks as we discussed in the previous section. Taking into account this information, a PI loop algorithm is performed to get the value to be applied to each DAC chip in order to change the local oscillator frequency to follow the master one (in a slave mode). One thing to be into consideration is that the process must be determinism and it only can be ensured if there is only an interrupt source and nothing can stop the SoftPLL operation.

\subsection{Software}

%% ---------------- From WR-ZEN article (EFTF2016) ------------------------
%
%In this section, the software components needed to run a
%Linux kernel/Baremetal application on the WR-ZEN board are
%described. The Zynq devices needs a binary file (BOOT.bin)
%that is composed of a specific Xilinx bootloader known as First
%Stage Bootloader (FSBL), a gateware bitstream to program
%the FPGA and a baremetal application or a Second Stage
%Bootloader (SSBL) if Linux kernel must be loaded. The FSBL
%is encharged to initialize different peripherals, configure the
%FPGA with a bitstream and run the baremetal application
%or the SSBL. The baremetal application is encouraged to be
%coded with the Xilinx SDK because all the gateware details
%are imported to the software project and we can use all the
%functionalities of the Xilinx Board Package Support (BSP). On
%the other hand, the SSBL is a independent project and must be
%downloaded and compiled separately. The most common SSBL
%are U-boot [14] and Barebox [15]. The chosen bootloader is U-
%boot instead of Barebox because there is a Xilinx repository
%[16] that includes custom code for the Zynq devices. When
%everything is generated, the Xilinx SDK or bootgen tool must
%be used to pack all the binaries in a single file, the BOOT.bin.
%The following step is to compile the Linux kernel, kernel
%modules, libraries and userspace tools. To face this task, there
%are two ways. The first one is to compile every component
%separately and manually. It is very slow, tedious and error
%prone but it is the best way to control the different steps
%and customize them if necessary. On the other hand, there
%are some tools that automate the process such as Yocto [17]
%or Buildroot [18]. However, they present a disadvantage: the
%user loses the control and it is more difficult to add some mod-
%ifications because the tool does everything automatically. For
%the reference design, the Buildroot is used to ease and speed
%up the compilation of the Linux kernel, U-boot bootloader, the
%kernel modules and userspace tools. The Buildroot package is
%retrived from the official project website. It is very configurable
%and includes the Kconfig support to enable/disable the different
%features similar to the Linux kernel. Although the Buildroot
%eases very much the compilation process, it has many options
%and may be confusing for a non-expert user. To solve this
%issue, a set of scripts have been implemented to perform all
%the actions needed and configuration files for the Busybox,
%Linux kernel and the Buildroot are provided. This scripts are
%based on others from the WR Switch Software project [19] of
%the OHWR repository.
%In addition of the Linux kernel and the bootloader, some
%kernel modules and userspace tools for the WR-ZEN board
%have been written. The main kernel driver is the WR-ZEN
%carrier, known as zen, and is responsible for reprogramming
%the FPGA device and reading the EEPROM information of
%the WR-ZEN board. This driver is based on the fmc-bus
%[20] (OHWR) and it also gives NIC capabilities to manage
%the optical fiber ports as standard network interfaces from
%the Linux kernel. Some userspace tools to read/write the
%FPGA register (zenmem), reprogram the FPGA bitstrean (zen-
%fwloader.sh), reprogram the soft-microprocessor program (zen-
%cl) and send commands to the soft-microprocessor (zen-vuart)
%are included too. The driver and all these tools are inspired by
%the SPEC Software project [21] of the OHWR repository. As
%we saw in the previous section, the reference design has also
%a Fine Delay core that must be controlled by a specific kernel
%driver. Actually, there are two drivers (zio [22] and fmc-fine-
%delay [23]) and some userspace tools in the OHWR for the
%Fine Delay FMC card in a SPEC card. Using these ones as
%starting point, some minor modifications have been made to
%incorporated them to the WR-ZEN reference design.
%
%% ------------------------------------------------------------------------

The WR-ZEN can take advantage of having a hard dual core microprocessor because it allows to deploy a Linux system in the platform or a baremetal application that manages the hardware resources directly. In the SKA system, the WR-ZEN is used with a Linux kernel to implement the specific applications needed by the system. To accomplish this task, a process must be defined to build the kernel and all software components (daemons, applications, etc) in a simple and automatic way. The manual building of the Linux kernel is not an acceptable procedure because it requires human-intervention and it is tedious and error prone. Other solution could be to use an existing software tool (Buildroot or Yocto for example), however, it used to have some limitations to customize it. On the other hand, a custom and automatic building system could be coded but it often carries coding several scripts and it is high time consuming. The final solution is a mixed scheme: a software tool known as Buildroot and some scripts to perform additional tasks. Buildroot is responsible for generating a new Operating System based on Linux with multiple applications and the root file system to get a fully operational environment. However, its main disadvantage is the lost of control due the fact all the steps are automatic and it has advanced topics that are difficult for newbies. To solve this issue, some custom scripts (inspired by WR Switch Software project ones) are added to allow user intervention and provides standard configuration for Linux kernel, Busybox and root filesystem. The Busybox is a software package that contains most used and important tools in Linux environment. Nevertheless, it is optimized for embedded devices because it only generates a single binary for all tools. The root filesystem is the main file holder for Linux system and it stores many files including tools, drivers, configuration files, initialization scripts, etc. Moreover the basic Linux components, some userspace tools and custom kernel drivers have been developed to manage the main modules in the WR-ZEN reference design. The kernel drivers that have been implemented or modified from others are the following:

\begin{itemize}
	\item {\textbf{fmc:} It is retrieved from OHWR repository and it has not been modified. Its main purpose is implementing a generic support for FMC bus in the Linux kernel. It is necessary because many other drivers use its generic functions.}
	\item {\textbf{zen:} It is the main driver for the WR-ZEN board. It manages all the IP cores in the design and provides advanced features such as character device methods, NIC capabilities integrated with the Linux system, reprogram the FPGA with the reference design, etc.}
	\item{\textbf{zio:} It is retrieved from OHWR repository and it has not been modified. It creates the ZIO bus that exports its attributes through the SysFS.}
	\item{\textbf{fmc-fine-del:} It is based on the OHWR repository version and includes some modifications for the WR-ZEN platform. It controls the Fine Delay FMC core and all its working modes. An important feature of this driver is the reprogramming of the FPGA with the Fine Delay FMC bitstream through the \textit{zen} API.}
	\item {\textbf{zen-nic:} It is additional module that is charged to enable/disable NIC methods. However, it does not implement these functions because they are in \textit{zen} kernel module. The \textit{zen-nic} is necessary because the Fine Delay FMC driver reprograms the FPGA and for this reason, the network initialization can not be performed in the \textit{zen} module directly.}
\end{itemize}

There are dependencies between the different kernel drivers and it establishes the installation order. The \textit{zen} one depends on \textit{fmc}. The \textit{fmc-fine-del} needs \textit{zen}, \textit{zio} and \textit{fmc}. The \textit{zen-nic} only uses the \textit{zen}.

Moreover, there are several custom userspace tools related with drivers previous explained. Those that use the \textit{zen} driver API are \textit{zenmem} that is responsible for accessing memory map of the WR-ZEN IP cores, \textit{zen-fwloader} that programs the FPGA with a given bitstream, \textit{zen-vuart} and \textit{zen-cl} that allows talking to the soft-microprocessor (included in gateware) and loading other firmware respectively. In addition, the  \textit{fmc-fine-del} driver has associated tools such as \textit{fmc-fdelay-board-time} that is used to get the current time, \textit{fmc-fdelay-pulse} that generates pulses with certain characteristics (frequency, initial delay, duty cycle, etc), \textit{fmc-fdelay-input} that allows to poll the input connector to detect any incoming signal, \textit{fmc-fdelay-list} that enumerates the Fine Delay FMC cards plugged in the system (only one for WR-ZEN but however more for conventional PCs), \textit{fmc-fdelay-status} that check the status of Fine Delay FMC core and \textit{fmc-fdelay-term} that configures the termination of each channel among others.

In addition of Linux or baremetal environment described before, more components are needed  for the WR-ZEN platform. Before any application or Operating system can run, a specific bootloader must initialize some hardware devices. In the Zynq technology, there is a special bootloader known as First Stage Bootloader (FSBL) that is responsible for early initializations and it must be always present in the system. The FSBL is encharged to initialize different peripherals, configure the FPGA with a bitstream and run the baremetal application or the Second Stage Bootloader (SSBL). The most common SSBL are U-boot and Barebox. The chosen bootloader is U-boot instead of Barebox because there is a Xilinx repository that includes custom code for the Zynq devices. Finally, the FSBL, bitstream and SSBL/baremetal application must be packed in a binary file named BOOT.bin using the Xilinx SDK environment or bootgen tool and put in a FAT-32 partition of a SD card.

\section{Test}

\section{Results}

\section{Conclusion}

\section{Future work}

\section{Acknowledgments}

\kcmdnote{Cite Manolo's projects if you do not want to die... Forever...}
The authors would like to thank to the CERN BE-CO-HT group, the WR community, the Seven Solutions staff and
other institutions such as JIVE (especially Paul Boven) for its collaboration testing the
WR-ZEN board. This work has been partially funded by the
Horizon 2020 (H2020) ASTERICS (grant number 653477) and
VITVIR (TIC-8120, Junta de Andalucia) projects.

\section*{References}

\bibliography{mybibfile}

\end{document}